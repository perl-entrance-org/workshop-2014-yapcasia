# Perl入学式 in YAPC::Asia

本日の資料はこちらです: http://bit.ly/1vUBkYv

___
## 諸注意とお願い
- これまでのPerl入学式に参加されている方へ
    - 今回のカリキュラムには, ｢Perl入学式 #1｣や｢Perl入学式 #2｣で既に習っている内容も含まれています
    - 練習問題が早く終わった場合, コードゴルフ(出来るだけコードを短くする)に挑戦してみたり, 周囲で詰まっている方のサポートをして頂けると嬉しいです

___
## 諸注意とお願い
- ｢Perl入学式 in YAPC::Asia｣がはじめてのPerl入学式という方へ
    - 今回のカリキュラムは, ｢Perl入学式 #1｣や｢Perl入学式 #2｣の内容を濃縮したものにプラスαしたものとなっています
    - 初学者の方には, 少し駆け足に感じられるかもしれません
    - そのような方の為に, 我々サポーターが常にスタンバイしています!

___
## 諸注意とお願い
- ｢Perl入学式 in YAPC::Asia｣がはじめてのPerl入学式という方へ
    - ｢これ, どういう事だろう?｣と疑問に思った場合, 講師が説明している時でも遠慮せず挙手して質問して下さい
        - 講師やサポーターが, 適宜その疑問を解決します!
    - 練習問題についても, 分からない所や, ｢そもそも何をしたらいいのか...｣という場合, 遠慮せずにサポーターの力を借りて行きましょう!

___
## 諸注意とお願い
- ｢Perl入学式 in YAPC::Asia｣がはじめてのPerl入学式という方へ
    - 説明を聞いて, ｢何もわからなかった...!｣というのは, **恥ずかしい事ではありません**
    - 最初は模写でも, サポーターの言う通りに書くというのでもいいので, とにかく書いていきましょう, 動かしましょう
    - そして, 可能であれば家等々でも繰り返し書きましょう. そうすることで, コードが書けるようになっていくと思います
        - その際の支援も, もちろんPerl入学式サポーターズにお任せです!
        - ｢#Perl入学式｣のハッシュタグを付けて, つぶやいて下さい

___
## 諸注意とお願い
- Perl入学式は, ｢ただ聞いていたらOK｣という勉強会では**ありません**
    - 我々には, 皆さんの｢プログラミング勉強したい!｣, ｢この機会に挑戦したい!｣という気持ちに, 資料とサポートで応える事しか出来ません...
- 是非, Perl入学式とそのサポーター陣を有効に活用してください. 今日この時間だけでなく, Twitterやメール, Perl入学式歓談所などでの質問も大歓迎です
    - 詳しくはこちら!: http://perl-entrance.org/

___
## お願い
- twitterのハッシュタグは｢#Perl入学式｣です
    - 暇な時間があれば, ｢今こんな状況だよ!｣とつぶやいて頂けると嬉しいです
    - また, どうしても質問しにくい...! という場合, twitterで｢XXXXがわからない... #Perl入学式｣のようにつぶやいてみてください
    - サポーターが全力で支援させて頂きます!

---
# アイスブレイク?

___
## 自己紹介タイム

- せっかく同じ机に座った縁, 今日一緒にPerlを学ぶ仲間に自己紹介をしましょう
    - すいません, 時間があまりないので1人1分でお願い致します...
- 必ず, 次の内容は話してください:
    - 名前(何と呼べばいいか)
    - どうして, Perl入学式に行ってみようと思ったのか
        - Perlでやってみたいこと, 素直な気持ち, どんな形でもOKです!

---
# 今日のテーマ

___
## Bot
- ｢人工無能｣などと呼ばれたりもする
- 人間の呼びかけに対し, 予めプログラムされたレスポンスをする仕組み
    - ｢こんにちは!｣という発言に｢こんにちは!｣と返したり...
    - ｢今日の天気は?｣という発言に｢晴れだよ!｣と返したり...
        - 天気予報は, 例えば[Livedoor Weather Web Service](http://weather.livedoor.com/weather_hacks/webservice)などを使って取得させることができます!

___
## BotとPerl
- Perlのモジュールを活用すれば, 様々なサービス上で動くBotを作ることができます
    - Twitter用Bot
        - Net::Twitter::Lite
        - AnySan::Provider::Twitter / AnySan
    - IRC用Bot
        - App::Ikachan / UnazuSan
    - Skype用Bot
        - App::Tacochan / UnazuChan
    - HipChat用Bot
        - AnyEvent::XMPP

___
## 端末で動くBot
- 今日は, 皆さんのPCにある端末(ターミナル)上で動くBotを作ってみたいと思います
    - 仕組みとしては, TwitterやIRC, Skype等で動くBotに似ています
- Botを作りながら, これまで学んできたPerlの基礎的な知識の復習や, これから先(Perl入学式 第3回以降)に学ぶ内容の予習, そしてモジュールの活用について体験していきます

___
## 余裕があったらデモ

___
## 今日やること
- カリキュラム
    - これまでの基礎
    - Botの作成
    - モジュールを利用した機能拡張
- 2時間半という制約上, どうしても時間が足りなくなる可能性があります
    - それでも, 説明を省略したりしてカリキュラムを無理やり完走する, ということは｢絶対にしません!｣
    - 大変申し訳ありませんが, ご理解頂ければ幸いです

---
# これまでの復習

---
# 文字の入出力と変数

___
## おまじない

    #!/usr/bin/env perl
    use strict;
    use warnings;

- おまじないとして, 冒頭の3行を書くようにしよう
- `use strict` -> 厳密な書式を定めたり, 未定義の変数を警告するといった効果があります
- `use warnings` -> 望ましくない記述を警告してくれる効果があります
    - 以下, この資料のサンプルコードでは｢お約束｣を省略します
    - 書かれているものとして扱ってください

___
## 文字の出力

    print 'Hello, world!\n'; # => Hello, world!\n
    print "Hello, world!\n"; # => Hello, world![改行]

- `print`を使うことで, 指定した文字列を出力することができます
- 文字列は, `'`ないし`"`で囲います
    - `'`で囲った場合, その中の文字列がそのまま出力されます
    - `"`で囲った場合, その中の特殊な文字列(例えば, `\n` -> 改行, など)が有効になります

___
## 変数

    $scalar; # スカラ変数
    @array;  # 配列
    %hash;   # ハッシュ

- 変数は, いわば｢データを格納できる箱｣です
    - Perlの変数には, ｢スカラ変数｣, ｢配列｣, ｢連想配列(ハッシュ)｣という3種類の型があります
- ｢スカラ変数｣は, ｢1つの要素しか入らない箱｣と思って下さい
- ｢配列｣と｢連想配列(ハッシュ)｣は, ｢複数の要素を格納出来る箱｣と思って下さい
    - まずは, 1つの要素を格納できる｢スカラ変数｣について見て行きましょう

___
## スカラ変数
    my $hoge;
    $hoge = 1;
    my $foo = 3.14;
    $foo = "bar";

- スカラ変数の先頭には, `$hoge`のように`$`をつけます
    - `$`は`スカラ(scalar)`の`s`, と覚えるとよいでしょう
- `=`演算子を使うことで, 左辺のスカラー変数に右辺の値を入れる(代入する)ことができます
- 変数を宣言するとき(初めて使うとき)は, 先頭に`my` をつけます
- `Perl` では, C言語やJavaのように `int`や`char`といった型(データの種類)の区別はないので, 数値や文字列などを自由に代入することができます

___
## 変数の出力

    my $hoge = 1;
    print "$hoge\n"; # => 1
    print '$hoge\n'; # => $hoge\n

-  `print` を使うことで変数を出力することができます
- 変数を出力する場合は, `"(ダブルクォテーション)`の中に変数を書きましょう
    - `"`の中に変数を書くと, その変数の中身が展開されて表示されます
    - `'`の中では, 展開はされず, 全てがそのまま出力されます
        - 変数だけでなく, `\n`などもそのまま出力されます!
- `\n`は改行を意味します

___
## 文字の入力

    my $str = <STDIN>;
    chomp $str;
    print $str;

- 端末からPerlに対して, 標準入力を使って文字列を入力することができます
    - 1行目では, `<STDIN>`で端末から文字列を入力し, 入力された文字列を変数`str`に代入しています
    - `<STDIN>`で得られた文字列は行末に改行を含むため, 2行目の `chomp`で改行を削除しています

___
## 基本的な演算子(四則演算)

    my $hoge = 4;
    my $foo  = 2;
    my $res;
    $res = $hoge + $foo  # 4 + 2 = 6
    $res = $hoge - $foo  # 4 - 2 = 2
    $res = $hoge * $foo  # 4 * 2 = 8
    $res = $hoge / $foo  # 4 / 2 = 2
    $res = $hoge % $foo  # 4 % 2 = 0
    $res = $hoge ** $foo # 4 の 2乗 は 16

- `perl`では, C言語と異なりべき乗の計算を簡単に行うことができます

___
## 基本的な演算子(文字列連結)
    my $foo = 'hoge';
    my $bar = 123;
    my $baz = $foo . $bar; # hoge123
    print $foo . $baz . "\n"; # hogehoge123

- `.`で, 文字列を自由に連結することができます

___
## 演算の順番
    my $hoge = 2 + 4 * 3;   # 14
    my $fuga = (2 + 4) * 3; # 18

- 演算の順序は, `()`を付けることで変更することができます
    - 通常の数学と同じく, Perlも足し算･引き算より掛け算･割り算の優先順位が高いです
    - しかし, 2行目では`()`を付けることで足し算を先に計算させています

___
## 練習問題(hello.pl)

- `<STDIN>`を使って, 変数`$name`に名前を受け取ろう
- `$name`に格納した名前を使って, 挨拶をしよう
    - 例えば, ｢yusuke｣と入力したら, ｢こんにちは, yusukeさん!｣と表示するようにしてみよう

___
## 解答例

    use strict;
    use warnings;

    chonp(my $name = <STDIN>);
    print "こんにちは, $yusuke さん!";

---
# if, else文

___
## 制御構文(if)
    my $hoge = 1;
    if ( $hoge == 1 ) {
      print "OK\n"; # 条件が｢真｣の場合
    } else {
      print "NG\n"; # 条件が｢偽｣の場合
    }

- `==` は"右辺と左辺が等しければ真"であることを意味します
    - 真 = 条件が正しい, 偽 = 条件が正しくない
- ここでは`$hoge`が`1`と等しい場合に限り真となり, `OK`という文字が表示されます
- `$hoge`が1でなければ, 偽となるため`else`に処理が移り`NG`という文字が表示されます

___
## 制御構文(if)
    my $hoge = 1;
    if ( $hoge == 1 ) {
      print "OK\n"; # 条件が｢真｣の場合
    }

- `else`の部分は省略することもできます
    - この場合, 条件が偽の場合(`$hoge`が`1`ではない場合)は, 何の処理も行われません

___
## 数値の比較演算子
    == # 右辺と左辺が等しいならば真
    != # 右辺と左辺が等しくないならば真
    <  # 右辺より左辺が小さいならば真
    >  # 右辺より左辺が大きいならば真
    <= # 右辺が左辺以上ならば真
    >= # 右辺が左辺以下ならば真

- 数字同士を比較するときは, このような比較演算子を使います

___
## 文字列の比較演算子
    eq # 右辺と左辺が等しいならば真
    ne # 右辺と左辺が等しくないならば真
    lt # 右辺より左辺が小さいならば真
    gt # 右辺より左辺が大きいならば真
    le # 右辺が左辺以上ならば真
    ge # 右辺が左辺以下ならば真

- 数値を比較する場合は`==`や`!=`を使いますが, 文字列を比較する場合は`eq`や`ne`といった演算子を使います
    - もっとも, `eq`, `ne`以外はあまり使いません
    - 文字列の大小とは, 辞書順に並べた時に前にくるものが小さく, 後ろにくるものが大きいということです

___
## 文字列比較
    my $hoge = 'hello';
    if ( $hoge eq 'hello' ) {
        print "OK";
    } else {
        print "NG";
    }

- 今回は文字列を比較しているので, `==`ではなく`eq`を用いています

___
## Perlにおける真偽値

- Perlには, `true`や`false`などで真偽値を表すことはできません
- そのかわりPerlでは, 次の5つの値が｢偽｣の値(偽値)として扱われます
    - 数値｢0｣
    - 文字列｢'0'｣と｢''｣
    - 空のリスト｢( )｣
    - undef
- そしてこれ以外の値は, Perlでは全て真として扱われます

___
## 複数の制御構文
    my $hoge = 1;
    if ( $hoge == 1 ) {
        ...
    } elsif ( $hoge == 2 ) {
        ...
    } elsif ( $hoge == 3 ) {
        ...
    } else {
        ...
    }

- `elsif`を使うことで, 分岐条件をさらに増やすことができます

___
## 練習問題(even_odd.pl)

- `<STDIN>`で数値を1つ受け取り, その値が偶数なら｢even｣, 奇数なら｢odd｣と表示するプログラムを書いてみよう

___
## 解答例

    use strict;
    use wanrings;

    chomp(my $number = <STDIN>);
    if ($number % 2 == 0) {
        print "even";
    } else {
        print "odd";
    }

---
# for文, 配列

___
## 配列
    my @array = ( 1, "hoge", 3 );
    print "@array\n";    # 1 hoge 3

- 配列を使うことで, 数値や文字列をまとめて格納できます
- `=`演算子を使うことで, 左辺の配列に右辺の値を代入することができます
- 配列は変数名の前に`@`をつけます
    - `@`は`アレイ(array)`の`a`, と覚えるとよいでしょう
- 1行目の右側, `( ... )`の部分をリストと呼びます

___
## 配列

    my @array = ( 1, "hoge", 3 );
    print "$array[0]\n"; # 1
    print "$array[1]\n"; # hoge
    print "$array[2]\n"; # 3

- 配列の一つ一つの要素にアクセスする場合は`$変数名[添字]`を使います
    - 添字は1ではなく0からスタートして, 1ずつ増えます

___
## 配列
    my @array = ( 1, "hoge", 3 );
    print "$array[0]\n"; # 1

- `@変数名[添字]`ではない理由は, ｢配列に格納された1つの要素｣はスカラ(単一)のデータである為です
    - そのため, 先頭に`@`ではなく`$`が付きます

___
## 配列
    my @array = ( 1, "hoge", 3 );
    my $sum = $array[0] + $array[2];
    print "$sum\n" # => 4

- 配列の要素は普通のスカラ変数と同じように扱えるので, 代入や計算ができます

___
## 配列の要素数
    my @array = ( 1, "hoge", 3 );
    print scalar @array; # => 3
    print $#array; # => 2

- 配列を`scalar`演算子に与えると, 配列に格納されている要素の個数を取得できます
- `@array`に対して`$#array`と書くことで, 配列に格納されている最後の要素の添字を取得できます

___
## 範囲演算子
    my @array1 = ( 1, 2 );
    my @array2 = ( 1 .. 5 );
    my @array3 = ( @array1, 3 ); # (1, 2, 3)

- `()`を使うことで, 配列にをまとめて代入することができます
- 連続する数字であれば, 範囲演算子`..`を使って`1 .. 5`と書くことで`1以上5以下`の値を配列に代入できます
- 3行目のように, 数値や文字列だけでなく, 配列も組み合わせることができます

___
## reverse
    my @array1 = ( 5, 4, 3, 2, 1 );
    my @array2 = reverse ( 1 .. 5 ); # OK
    my @array3 = ( 5 .. 1 ); # NG

- `@array1`のように, 連番を逆の順番で配列に格納したい場合は`reverse`を使いましょう
    - 範囲演算子`..`は, 必ず右側の値が左側の値より大きくなければなりません
    - そのため, `@array2 = ( 5 .. 1 );`のように書くと`@array2`には空の要素が格納されるので注意しましょう

___
## sort
    my @array1 = ( 5, 4, 3, 2, 1 );
    my @sorted = sort @array1; # (1, 2, 3, 4, 5)

- `sort`を使うと, 配列の要素を並び替えます
    - `sort { $a <=> $b }`と書くと, 数値としてソートします
    - `sort { $a cmp $b }`, あるいは`sort`のみを書くと, 文字列としてソートします
    - `sort { $b <=> $a }`, `sort { $b cmp $a }`と書くと, 逆順にソートします
- 変数`$a`と`$b`はsortで使う為に予約されているので, *sort以外で使ってはいけません*

___
## for ループ
    my @array = ( 1, "hoge", 3 );
    for my $var ( @array ) {
      print "$var\n";
    }

- 配列の中身を走査するのに, `for`文があります
    - `foreach`と書いても問題ありません. 実はPerlの内部では, 同じように処理されます
- この場合, 変数`$var`に`$array[0]`, `$array[1]` ... という値が順番に代入され, 処理が行われます

___
## 練習問題(loop.pl)
- `<STDIN>`で数値を1つ(但し, 1以上の整数とします)受け取り, 0から入力した値まで連番として出力するプログラムを書いてみよう
    - 例えば, 入力を｢5｣にした場合, 0から5までの整数が出力されるようにしよう

___
## 解答例

    use strict;
    use warnings;

    chomp(my $i = <STDIN>);
    for my $var (0 .. $i) {
        print "$var, ";
    }

---
# Botを作ろう!

___
## Botを作ろう!
- ここまでの内容で, 駆け足ではありましたが｢Perl入学式 #2｣までの内容を振り返ってきました
    - これらの知識を使いながら, 実際にBotを作っていきましょう!

___
## Botが動く手順
- Botは, 次のような手順で動きます
    - 1. 入力を待つ
    - 2. 入力に応じて, 予め指定された動作をする
- ...という, 1. と 2. を繰り返していきます

___
## while

    while (1) {
        ...
    }

- このように, ｢延々と続くループ｣を実現するには, `while`を利用します
    - `while`は, `( ... )`の中が真である限り, `{`と`}`で囲まれた部分の処理を, 延々と続けます

___
## while

    while (1) {
        chomp(my $input = <STDIN>);
        print "$input";
    }

- このように書けば, 延々と｢入力したワードを｣, ｢表示する｣という処理を繰り返すことができます
    - 終わる時は, `Ctrl`キーと`C`キーを同時に押しましょう(強制終了)

___
## while

    while (1) {
        chomp(my $input = <STDIN>);
        if ($input eq 'exit') {
            last;
        }
        print "$input";
    }

- 毎回強制終了するのは面倒です. そこで, `exit`と入力するとプログラムが終了するようにしてみましょう
    - `while`や`for`のループの中で`last`を使うと, その繰り返し処理を強制的に終了することができます

___
## Botのベース

    while (1) {
        print ">>> ";
        chomp(my $input = <STDIN>);
        if ($input eq 'exit') {
            last;
        }
    }

- それでは, このコードを出発点にして, Botに様々な機能を与えていきましょう!

___
## 練習問題(bot_hello.pl)

    while (1) {
        print ">>> ";
        chomp(my $input = <STDIN>);
        if ($input eq 'exit') {
            last;
        }
    }

- 先ほどのコードを使って, ｢こんにちは｣と入力した時だけ, ｢こんにちは!｣と出力するようにしてみよう

___
## 解答例

    use strict;
    use warnings;

    while (1) {
        print ">>> ";
        chomp(my $input = <STDIN>);
        if ($input eq 'exit') {
            last;
        } elsif ($input eq 'こんにちは') {
            print "こんにちは!\n";
        }
    }

___
## おみくじ
- それでは, 次にBotにおみくじ機能を追加してみましょう
    - ｢おみくじ｣と発言すると, ｢大吉｣, ｢中吉｣, ｢小吉｣, ｢吉｣, ｢凶｣, ｢大凶｣のいずれかを出力するものです

___
## 乱数

    my $rand = rand(10); # 0から10未満の小数の乱数を返す

- Perlでランダムな値を得たい場合, `rand`を使います
    - 0から`rand`に与えた引数未満の, 小数の乱数を生成します
- もし, 乱数を整数で得たい場合は`int`を適用します
    - `int`は, 与えられた値の整数部のみを返す(小数点を切り捨てる)役割を持ちます

___
## おみくじ機能

    my @kuji = ('大吉', '中吉', '小吉', '吉', '凶', '大凶');
    while (1) {
        print ">>> ";
        chomp(my $input = <STDIN>);
        if ($input eq 'おみくじ') {
            my $selected = $kuji[ int rand (scalar @kuji) ];
            print "運勢は, $selected です!\n";
        }
    }

___
## 配列の中からランダムに選ぶ

    my @kuji = ('大吉', '中吉', '小吉', '吉', '凶', '大凶');
    my $selected = $kuji[ int rand (scalar @kuji) ];

- まず, `scalar @kuji`について
    - `scalar @kuji`で, `@kuji`の中にある要素の個数を取得している
    - この場合, `@kuji`には6個の要素が含まれているため, `@kuji` = 6, となります

___
## 配列の中からランダムに選ぶ

    my @kuji = ('大吉', '中吉', '小吉', '吉', '凶', '大凶');
    my $selected = $kuji[ int rand (scalar @kuji) ];

- 次に, `int rand ( scalar @kuji )`について
    - 先ほどの結果より, これは`int rand ( 6 )`になります
    - `rand`は, 0から引数未満の乱数を返すので, `rand ( 6 )`は0から5.9999 ... までの乱数を返します
    - このような`$array[ int rand( scalar @array ) ] `という書き方は, イディオム（熟語/成句）としてよく使われるので覚えてしまいましょう!

___
## 配列の中からランダムに選ぶ

    my @kuji = ('大吉', '中吉', '小吉', '吉', '凶', '大凶');
    my $selected = $kuji[ int rand (scalar @kuji) ];

- 最後に, `int`で整数部分のみを取り出す(小数点を切り捨てる)すれば, `int rand ( scalar @kuji )`は, 0から5までの乱数を返す, ということがわかります
    - 最後に, `$kuji[ ... ]`の部分で, `@kuji`の中から, 該当する添字の要素を取り出しています
- それでは早速, 実践してみましょう!

___
## 練習問題(bot_food.pl)

- おみくじ機能を参考にして, お昼ごはんの場所を提案してくれる機能を追加してみよう
    - ｢ごはん｣と入力すると, 次のお店から1つ選んでくれる機能です: ｢らすた(ラーメン屋)｣, ｢マクドナルド｣, ｢学食｣, ｢Hub｣
    - 例: ｢ごはん｣と入力 -> ｢らすたのラーメン｣と返す
- オプション: 2件提案してくれるようにしてみよう
    - 例: ｢ごはん｣と入力 -> ｢らすたのラーメンか, マクドナルド｣と返す
    - 提案する2件は同じ店が入っていてもOKです. 時間に余裕があれば, 重複しないように(常に別の店を提案するように)してみましょう

___

## 解答例

    my @food = qw/ らすた マクドナルド 学食 Hub /;
    while (1) {
        print ">>> ";
        chomp(my $input = <STDIN>);
        if ($input eq 'ごはん') {
            my $selected = $food[ int rand (scalar @food) ];
            print "$selected\n";
        } elsif ($input eq 'おみくじ') {
            ...
        }
    }

---
# モジュールの利用
___
## モジュールの利用

- それでは, このBotにモジュールを使って新しい機能を追加してみましょう
    - 今回は, [WebService::Livedoor::Weather](https://metacpan.org/pod/WebService::Livedoor::Weather)というモジュールを使います
    - このモジュールは, Livedoorの天気予報APIを利用して, 指定した地域の天気予報を取得出来るモジュールです
    - Botに, 天気を教えてくれる機能を追加してみましょう!

___
## モジュールのインストール

    $ which cpanm
    /Users/username/.anyenv/envs/plenv/shims/cpanm

- まず, モジュールをインストールする為のコマンド, `cpanm`がインストールできているかを確認します
    - 上記のように, `cpanm`が配置されている場所(パス)が表示されていれば, インストールできています
    - `cpanm not found`と表示された場合, 最寄りのサポーターを呼んで下さい

___
## モジュールのインストール

    $ cpanm WebService::Livedoor::Weather
    --> Working on WebService::Livedoor::Weather
    Fetching http://www.cpan.org/authors/id/Y/YT/YTURTLE/WebService-Livedoor-Weather-0.07.tar.gz ... OK
    Configuring WebService-Livedoor-Weather-0.07 ... OK
    Building and testing WebService-Livedoor-Weather-0.07 ... OK
    Successfully installed WebService-Livedoor-Weather-0.07
    1 distribution installed

- それでは, `WebService::Livedoor::Weather`をインストールしていきましょう
    - 最後に, `1 distribution installed`と出力されれば成功です
    - これ以外の出力が出た場合, 最寄りのサポーターを呼んで下さい

___
## 試してみる

- モジュールを早速Botに組み込むのではなく, まず別のスクリプトで動かしてみましょう
    - はじめて使うモジュールは, このようにして挙動を試してから使ってみた方が安心安全です
- その前に, このモジュールのドキュメントを見てみましょう

___
## ドキュメントを見る

    $ perldoc WebService::Livedoor::Weather

- このように入力すると, `WebService::Livedoor::Weather`のドキュメントを見ることができます
    - 英語ではありますが, `SYNOPSIS`に簡単な使い方が載っていますので, ひとまずこれを見ることが出来れば十分です

___
## SYNOPSISを試してみる

    use utf8;
    use WebService::Livedoor::Weather;
    binmode STDOUT, ':utf8';
    my $lwws = WebService::Livedoor::Weather->new;
    my $ret = $lwws->get('130010'); # '130010' is Tokyo's city_id.
    printf "%s\n---\n%s\n", $ret->{title}, $ret->{description}->{text};

- このコードを, `weather.pl`という名前で保存し, 実行してみましょう.
    - 今日の東京の天気予報と, その詳細が確認できると思います
    - できなかった方は最寄りのサポーターを呼んで下さい
- それでは, SYNOPSISのコードを詳しく見ていきましょう

___
## SYNOPSISを試してみる

    $lwws = WebService::Livedoor::Weather->new;

- この行では, `$lwws`という変数に, WebService::Livedoor::Weatherのオブジェクトを作っています
    - オブジェクトとは, 簡単に言えば｢様々なメソッドやデータを持ったスカラ変数｣だと思っておいて下さい
    - `$lwws`という変数の中には, このオブジェクトを作る為の`new`や, 実際に天気予報を取得するための`get`という関数(メソッド)が含まれています

___
## SYNOPSISを試してみる

    $lwws = WebService::Livedoor::Weather->new;

- 関数とは, 一言で言えば｢コードをまとめたもの｣です
    - 同じコードは, 関数として1つにまとめてあげることで, コードが読みやすくなります
    - また, コードの修正もとても簡単になります
        - 詳しくは, 今後のPerl入学式で紹介していきます
- なお, このようなコードの書き方は, ｢オブジェクト指向｣のPerlと呼びます

___
## SYNOPSISを試してみる

    $ret = $lwws->get('130010'); # '130010' is Tokyo's city_id.

- 先ほど, `$lwws`には, 天気予報を取得するための`get`というメソッドが含まれている, と書きました
    - この関数は, オブジェクト(`$lwws`)とメソッド名の間に, アロー(`->`)を書くことで呼び出すことができます
    - 関数名(メソッド名)の後に, `()`を書くと, 関数に対して値(引数)を渡すことができます
        - この場合, 東京の都市IDである｢130010｣という値を渡しています

___
## SYNOPSISを試してみる

    printf "%s\n---\n%s\n", $ret->{title}, $ret->{description}->{text};

- `$ret->{title}`や`$ret->{description}->{text}`は, ｢リファレンス｣を使っています
    - リファレンスは, Perlで複雑なデータ構造を実現するための仕組みです
    - リファレンスについては, 今後のPerl入学式で詳しく紹介していきます

___
## Botに組み込む

- それでは, `WebService::Livedoor::Weather`をBotに組み込んでいきましょう
    - 今回は, ｢今日の天気｣と入力すると, その日の東京の天気を教えてくれる機能を追加してみます
    - 次のページのコードを, `bot_weather.pl`というタイトルで保存し, 実行してみましょう

___
## Botに組み込む

    use strict;
    use warnings;
    use utf8;
    binmode STDIN, ':utf8';
    binmode STDOUT, ':utf8';

    use WebService::Livedoor::Weather;

    my $lwws = WebService::Livedoor::Weather->new;
    while (1) {
        print ">>> ";
        chomp(my $input = <STDIN>);
        if ($input eq '今日の天気') {
            my $weather = $lwws->get('130010');
            my $today   = $weather->{forecasts}->[0]->{telop};
            print "今日の天気は, $today です!\n";
        }
    }

___
## Botとモジュール

- このように, モジュールを使えば, Botを含む様々なプログラムに, 簡単に機能を追加することができます
    - Perlを使う上で, モジュールをうまく使うのはとても大切なポイントです
    - ｢こういう事をしたいなあ...｣と思った時は, [CPAN](http://www.cpan.org/index.html)や[MetaCPAN](https://metacpan.org/)などを使ってモジュールを調べてみると, ｢やってみたい事｣が簡単に実現できるモジュールが既に存在するかもしれません

___
## 最終問題
- Botに新しい機能を付け加えてみよう!
    - ここまで作ってきたBotに, 新しい機能を付け加えてみよう
    - 例えば...
        - ｢発言したら, 必ず何かしらのレスポンスを返してくれる｣機能とか...
        - ｢サイコロ｣と発言したら, 1から6までの数字のいずれかを返してくれる機能とか...
    - もちろん, モジュールを使ってもOKです!
        - [Acme::SuddenlyDeath](https://metacpan.org/pod/Acme::SuddenlyDeath), [Acme::Nyaa](https://metacpan.org/pod/Acme::Nyaa) ...
- ｢こういうのが作りたいんだけど, どうしたらいいんだろう?｣というのがあれば, 是非サポーターと相談してみてください!

___
## To be continued...
- 今日はPerlのベースの部分を学びながら, 非常に簡単なアプリケーションを書いてみました
    - ｢引き続き勉強してみたい!｣と思った方は, 是非次回のPerl入学式からご参加頂けると嬉しいです
    - 次回予告等は http://perl-entrance.org でご確認下さい!
- また, ブログを書くまでがYAPC, そしてブログを書くまでがPerl入学式です!
    - 参加してみた感想を, 是非ブログ等に書いて頂ければ嬉しいです
